<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pastebin Lite - Technical Documentation</title>
    <style>
        :root {
            --bg: #0f1115;
            --surface: #1a1d23;
            --primary: #818cf8;
            --text-main: #f3f4f6;
            --text-muted: #9ca3af;
            --border: #2d313a;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            line-height: 1.6;
            margin: 0;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            color: var(--primary);
            margin-top: 2rem;
        }
        h1 { border-bottom: 2px solid var(--border); padding-bottom: 1rem; }
        .card {
            background: var(--surface);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            margin-bottom: 1.5rem;
        }
        code {
            background: #272a30;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            color: #d1d5db;
        }
        pre {
            background: #272a30;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
        }
        ul { padding-left: 1.5rem; }
        li { margin-bottom: 0.5rem; }
        .highlight { font-weight: bold; color: #fff; }
    </style>
</head>
<body>

    <h1>Pastebin Lite: Technical Walkthrough</h1>
    <p>This document explains how your application is built, the technologies used, and the logic behind every feature. Use this to prepare for any questions about the project.</p>

    <div class="card">
        <h2>1. The Technology Stack</h2>
        <ul>
            <li><strong>Next.js 15 (App Router):</strong> The framework running the entire app. It handles both the frontend (what users see) and backend (API routes).
                <ul>
                    <li><em>Why?</em> It allows us to build "Server Components" for speed and SEO, and "Client Components" for interactivity (like forms) in one project.</li>
                </ul>
            </li>
            <li><strong>Supabase (PostgreSQL):</strong> The database where we store all the pastes.
                <ul>
                    <li><em>Why?</em> It provides a robust, real-time ready SQL database that is free and extremely reliable.</li>
                </ul>
            </li>
            <li><strong>TypeScript:</strong> The coding language.
                <ul>
                    <li><em>Why?</em> It adds "safety" to JavaScript, preventing elementary bugs like trying to view a paste that doesn't exist.</li>
                </ul>
            </li>
            <li><strong>CSS Modules / Global CSS:</strong> The styling.
                <ul>
                    <li><em>Why?</em> Kept it simple and lightweight without heavy external libraries like Bootstrap or Tailwind (unless requested), ensuring fast loading.</li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="card">
        <h2>2. How "Creating a Paste" Works</h2>
        <p>This flow happens in <code>app/api/pastes/route.ts</code> and <code>app/page.tsx</code>.</p>
        
        <h3>Frontend (The Form)</h3>
        <p>The form captures three inputs: <code>Content</code> (text), <code>Expiration Time</code> (optional), and <code>Max Views</code> (optional). When you click "Create", it sends this JSON data to your backend API.</p>

        <h3>Backend (The Logic)</h3>
        <ol>
            <li><strong>Validation:</strong> The server checks if content exists. If not, it rejects the request.</li>
            <li><strong>ID Generation:</strong> We create a random alphanumeric ID (e.g., <code>5XNsUwWn9o</code>).</li>
            <li><strong>Expiration Calculation:</strong> 
                <br><code>ExpiresAt = CurrentTime + TTL_Seconds</code>
                <br>We store this exact future timestamp in the database.
            </li>
            <li><strong>Insert to DB:</strong> We run an SQL <code>INSERT</code> command to save the paste.</li>
        </ol>
    </div>

    <div class="card">
        <h2>3. SQL Structure (The Database)</h2>
        <p>We use a single table called <strong>Pastes</strong>.</p>
        <pre>
CREATE TABLE public.pastes (
  id text PRIMARY KEY,            -- Unique Random ID (e.g. 'abc1234')
  content text NOT NULL,          -- The actual text/code
  created_at timestamp,           -- When it was made
  expires_at timestamp,           -- When it should die (NULL = never)
  max_views integer,              -- Max allowed views (NULL = infinite)
  current_views integer DEFAULT 0 -- How many times it has been seen
);
        </pre>
    </div>

    <div class="card">
        <h2>4. The "View Limit" Logic (Crucial!)</h2>
        <p>This is the most technically interesting part. Handling "Max Views" incorrectly causes bugs where multiple people view a paste at the same time, exceeding the limit.</p>
        
        <h3>The Problem: Race Conditions</h3>
        <p>If two people load the page at the exact same millisecond, standard code might show the paste to <em>both</em> of them, incorrectly counting only 1 view. </p>

        <h3>Our Solution: Atomic Increments</h3>
        <p>We use a custom Database Function (RPC) called <code>increment_view_count</code>.</p>
        <pre>
CREATE FUNCTION increment_view_count(row_id text) RETURNS void AS $$
BEGIN
  UPDATE pastes
  SET current_views = current_views + 1
  WHERE id = row_id;
END;
$$ LANGUAGE plpgsql;
        </pre>
        <p><strong>Why is this special?</strong> Because the Database (PostgreSQL) processes this transactionally. Even if 100 requests come in, it queues them up one by one, ensuring the count is 100% accurate.</p>
    </div>

    <div class="card">
        <h2>5. How "Expiration" Works (Lazy Deletion)</h2>
        <p>You asked why we don't delete rows immediately. We use a strategy called <strong>Lazy Expiration</strong>.</p>
        <ul>
            <li>We do <strong>not</strong> have a timer constantly checking the database (this is expensive/complex).</li>
            <li>Instead, when a user <strong>requests</strong> a paste, we check:</li>
        </ul>
        <pre>if (Now > Paste.ExpiresAt) { Return 404 (Not Found) }</pre>
        <p>To the user, it looks exactly like it was deleted. The data sits harmlessly in the DB until you manually clean it up.</p>
    </div>

    <div class="card">
        <h2>6. Directory Structure Explained</h2>
        <ul>
            <li><code>app/page.tsx</code>: The Homepage. Uses <code>"use client"</code> because it has a form (interactivity).</li>
            <li><code>app/p/[id]/page.tsx</code>: The View Paste page. Uses <code>[id]</code> (Dynamic Routing) to catch any URL like <code>/p/abc</code> or <code>/p/123</code>.</li>
            <li><code>lib/supabase.ts</code>: Helper file that creates the connection to Supabase only once, so we don't open too many connections.</li>
            <li><code>.env</code>: The secret file. It holds your Supabase URL and Key. This file is <strong>never</strong> committed to GitHub for security.</li>
        </ul>
    </div>

</body>
</html>
